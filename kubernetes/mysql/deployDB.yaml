---
- name: Deploy MySQL to Kubernetes
  hosts: kubernetes_master
  vars_files:
    - "{{ inventory_dir }}/../group_vars/all.yml"
    - "{{ inventory_dir }}/../group_vars/{{ environment }}.yml"
    - "{{ inventory_dir }}/../group_vars/secrets.yml"

  tasks:
    - name: Ensure namespace exists
      k8s:
        api_version: v1
        kind: Namespace
        name: "{{ kube_namespace }}"
        state: present

    - name: Check if MySQL secret already exists
      k8s_info:
        api_version: v1
        kind: Secret
        namespace: "{{ kube_namespace }}"
        name: mysql-secrets
      register: mysql_secret_info
      failed_when: false
      changed_when: false

    - name: Create MySQL secrets if not exists
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: mysql-secrets
            namespace: "{{ kube_namespace }}"
          type: Opaque
          data:
            root-password: "{{ (mysql_root_password | string) | b64encode }}"
            username: "{{ (mysql_app_user | string) | b64encode }}"
            password: "{{ (mysql_app_password | string) | b64encode }}"
      when: mysql_secret_info.resources | length == 0

    - name: MySQL secrets already exist — skip creation
      debug:
        msg: "Secrets already exist — keeping existing passwords"
      when: mysql_secret_info.resources | length > 0

    - name: Create standard StorageClass (if not exists)
      k8s:
        state: present
        definition: "{{ lookup('file', playbook_dir + '/standard-storageclass.yaml') | from_yaml }}"

    - name: Check if PersistentVolume already exists
      k8s_info:
        kind: PersistentVolume
        name: mysql-pv
      register: mysql_pv_info
      failed_when: false
      changed_when: false

    - name: Create PersistentVolume if not exists
      k8s:
        state: present
        definition: "{{ lookup('file', playbook_dir + '/mysql-pv.yaml') | from_yaml }}"
      when: mysql_pv_info.resources | length == 0

    - name: Delete MySQL PVC (if exists)
      k8s:
        kind: PersistentVolumeClaim
        name: mysql-pvc
        namespace: "{{ kube_namespace }}"
        state: absent
        wait: yes
      ignore_errors: yes

    - name: Check if MySQL PVC already exists
      k8s_info:
        kind: PersistentVolumeClaim
        namespace: "{{ kube_namespace }}"
        name: mysql-pvc
      register: mysql_pvc_info
      failed_when: false
      changed_when: false

    - name: Deploy MySQL PVC if not exists
      k8s:
        state: present
        namespace: "{{ kube_namespace }}"
        definition: "{{ lookup('template', 'pvc.yaml') | from_yaml }}"
      when: mysql_pvc_info.resources | length == 0

    - name: Deploy MySQL Service
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: mysql-service
            namespace: "{{ kube_namespace }}"
            labels:
              app: fullstack
              tier: database
          spec:
            ports:
            - port: 3306
              targetPort: 3306
            selector:
              app: fullstack
              tier: database
            clusterIP: None

    - name: Deploy MySQL
      k8s:
        state: present
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mysql
            namespace: "{{ kube_namespace }}"
            labels:
              app: fullstack
              tier: database
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: fullstack
                tier: database
            strategy:
              type: Recreate
            template:
              metadata:
                labels:
                  app: fullstack
                  tier: database
              spec:
                containers:
                - name: mysql
                  image: "mysql:{{ mysql_version | default('8.0') }}"
                  ports:
                  - containerPort: 3306
                  env:
                    - name: MYSQL_ROOT_PASSWORD
                      valueFrom:
                        secretKeyRef:
                          name: mysql-secrets
                          key: root-password
                    - name: MYSQL_DATABASE
                      value: "{{ mysql_database_name | default('mydb') }}"
                    - name: MYSQL_USER
                      valueFrom:
                        secretKeyRef:
                          name: mysql-secrets
                          key: username
                    - name: MYSQL_PASSWORD
                      valueFrom:
                        secretKeyRef:
                          name: mysql-secrets
                          key: password
                  volumeMounts:
                  - name: mysql-persistent-storage
                    mountPath: /var/lib/mysql
                  resources:
                    requests:
                      cpu: "{{ mysql_cpu_request | default('500m') }}"
                      memory: "{{ mysql_memory_request | default('1Gi') }}"
                    limits:
                      cpu: "{{ mysql_cpu_limit | default('1000m') }}"
                      memory: "{{ mysql_memory_limit | default('2Gi') }}"
                  livenessProbe:
                    exec:
                      command: [ "mysqladmin", "ping" ]
                    initialDelaySeconds: 30
                    periodSeconds: 10
                    timeoutSeconds: 5
                  readinessProbe:
                    exec:
                      command: [ "mysqladmin", "ping" ]
                    initialDelaySeconds: 5
                    periodSeconds: 5
                    timeoutSeconds: 3
                volumes:
                - name: mysql-persistent-storage
                  persistentVolumeClaim:
                    claimName: mysql-pvc

    - name: Verify MySQL deployment
      command: >
        kubectl rollout -n {{ kube_namespace }} status deployment/mysql --timeout=300s
      register: rollout_result
      failed_when: rollout_result.rc != 0
      changed_when: false
